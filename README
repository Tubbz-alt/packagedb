================
Fedora PackageDB
================

:Author: Toshio Kuratomi
:Contact: toshio@fedoraproject.org
:Date: Wed 13 May, 2009
:Version: 0.4.x

The `PackageDB` keeps track of package ownership within Fedora.

.. contents::

-------
Project
-------

The `PackageDB` was started in January of 2007 to remove some of the hurdles
that made it more time consuming to maintain packages in Fedora after CVS
acls were introduced.  The intial goal was to take information about who owned,
comaintained, and was allowed to commit changes to a package and put it in a
database where owners could edit it.

The system began to be used by cvsadmins in July of 2007, and was opened for
general use in September.  At present it allows general users to manage the
ownership of packages and allows admins to add new packages or change things
when the owner is unresponsive.  A webUI is open for everyone and a simplistic
commandline client works for admin requests.

.. _`PackageDB`: https://fedorahosted.org/packagedb

Future goals
============

We're trying to manage our Roadmap_ of new features in trac.  So far it's
working out well.  If you have a new feature request, please open a
`trac ticket`_ and we'll add it to the schedule to be worked on.

.. _`Roadmap`: https://fedorahosted.org/packagedb/roadmap
.. _`trac ticket`: https://fedorahosted.org/packagedb/report/3

------------
Installation
------------

Although it's not working yet, the goal is to be able to run::

  paver build
  paver install --root ${path to installation}

and have a working installation.

Running from a Checkout
=======================

If you want to run from a checkout, you can perform the following commands::

Install Prerequisites
~~~~~~~~~~~~~~~~~~~~~
::
  yum -y install python-genshi TurboGears python-turbojson postgresql-server \
    postgresql-contrib python-TurboMail python-bugzilla python-fedora \
    python-psycopg2 python-sqlalchemy python-feedparser koji mod_wsgi \
    python-paver httpd mod_ssl babel python-cpio xz python-argparse \
    python-mako python-memcached python-migrate pytz python-minimock
    python-webtest

Get and Build the Source
~~~~~~~~~~~~~~~~~~~~~~~~
::
  bzr branch bzr://bzr.fedorahosted.org/bzr/packagedb/fedora-packagedb-devel
  cd fedora-packagedb-devel
  paver egg_info
  paver build --install-conf=`pwd` --install-data=`pwd` --install-sbin=`pwd`

If you're running Fedora 17, you may have trouble with CherryPy.  Try running::

  PYTHONPATH=/usr/lib/python2.7/site-packages/CherryPy-2.3.0-py2.7.egg paver egg_info
  PYTHONPATH=/usr/lib/python2.7/site-packages/CherryPy-2.3.0-py2.7.egg paver build --install-conf=`pwd` --install-data=`pwd` --install-sbin=`pwd`

Configuration files
~~~~~~~~~~~~~~~~~~~
First copy the pkgdb.cfg.sample file to pkgdb.cfg, test.cfg.sample to test.cfg 
and db_setup.cfg.sample to db_setup.cfg. 

We use three different types of access to the database.
o superuser - to create and modify database schema (username: postgres or test)
o common - used by webserver to access database for example (username: pkgdbadmin)
o read-only - read-only access (username: pkgdbreadonly)

Edit each .cfg to configure the server to see your database.  
You'll need to set fas.username to a username (your Fedora Account System username will work), 
fas.password (if you use your username, your password will work), and sqlalchemy.dburi.  

The dburi will differ according to purpose of the config file.

In pkgdb.cfg that is used by webserver and pkgdb tools scripts::

  sqlalchemy.dburi="postgres://pkgdbadmin:bunbunbun@localhost/pkgdb"

In test.cfg it is more complex::

  sqlalchemy.dburi="postgres://pkgdbadmin:bunbunbun@127.0.0.1/test"
  database.admin_dburi="postgres://test:test@127.0.0.1/test"
  database.common_user='pkgdbadmin'
  database.readonly_user='pkgdbreadonly'

The testing framework is creating the DB during the tests so it has to know access to 
DB superuser account. The framework uses dburi set up in database.admin_dburi for that, 
so that it could spare sqlalchemy.dburi for dburi used by webserver or tools
that are tested.

In db_setup.cfg that is used for db schema management::

  sqlalchemy.dburi="postgres://postgres@/pkgdb"
  database.common_user='pkgdbadmin'
  database.readonly_user='pkgdbreadonly'

The use if db_setup.cfg is described below.

Make sure database.repo is set to path to your db_repo directory::

  database.repo="%(current_dir_uri)s/db_repo"


Setup the Database
~~~~~~~~~~~~~~~~~~

.. note:: postgresql 8.3 or higher is needed

Make sure postgres is set to allow connections over tcp/ip using password
authentication.

If you do not have /var/lib/pgsql/data/pg_hba.conf, it may be because this is
a fresh install of postgres.  Initialize the service by entering the following
command::
  sudo service postgresql initdb

This should create several files in the /var/lib/pgsql/data directory including
the pg_hba.conf file.

Edit the /var/lib/pgsql/data/pg_hba.conf as the user postgres.  You might find
a line like this::

  host	all 	all	127.0.0.1/32	ident sameuser

Instead of that line, you need one that looks like this::

  host	all	all	127.0.0.1/32	md5

Create the postgres users that can access the database.  You will be prompted
to enter a password for each database user twice for verification purposes.
Note that the pkgdb web interface will use the pkgdbadmin user.  Other scripts
which only read from the database can use the pkgdbreadonly user to read
information only::

  sudo /etc/init.d/postgresql start
  sudo -u postgres createuser -SDRPE pkgdbadmin
    Enter password for new role: <password>
    Enter it again: <password>
  sudo -u postgres createuser -SDRPE pkgdbreadonly
    Enter password for new role: <password>
    Enter it again: <password>

Note:: If you don't have sudo, you can use su - instead::

  su -
  /etc/init.d/postgresql start
  su - postgres
  createuser -SDRPE pkgdbadmin
    Enter password for new role: <password>
    Enter it again: <password>
  createuser -SDRPE pkgdbreadonly
    Enter password for new role: <password>
    Enter it again: <password>

Get some test data and import it into the database.  You want to grab the most
recent dump from http://fedorahosted.org/releases/p/a/packagedb like this
(look for a .dump.xz that looks recent in that directory)::

  wget https://fedorahosted.org/releases/p/a/packagedb/pkgdb-20120111.dump.xz
  xzcat pkgdb-20120111.dump.xz | sudo -u postgres psql

This is a rather large dump and can take a while to load.


Update the Database Schema
--------------------------

Currently the database dump is not up to date with the latest changes in the
devel branch. These steps won't be required after we get a healthy 0.5.x dbdump.
Run the following scripts to bring it up to date::

  sudo -u postgres psql pkgdb < update-schema/04_updates_to_make_db_match_the_model.sql
  python update-schema/05_migrate_version.py pkgdb.cfg > update-schema/05_migrate_version.sql
  sudo -u postgres psql pkgdb < update-schema/05_migrate_version.sql
  sudo -u postgres psql pkgdb < update-schema/06_update_statuscodetranslation.sql
  sudo -u postgres psql pkgdb < update-schema/07_update_collectionpackage_view.sql

TODO: remove the lines above in favour of

If your database is not up to date with the latest changes in your branch 
(DB created from dump, merged in db updates),run the following scripts 
to bring it up to date::

  sudo -u postgres python ./manage_db -c db_setup.cfg upgrade


Create the database from scratch
--------------------------------

If you need fresh database for testing/development and are not interested in real life data
you can use::

  tg-admin sql create

This will try to create DB as user set in 'sqlalchemy.dburi', set rw permission to user in 'database.common_user'
and set read only permission to user in 'database.readonly_user'. 
Also note that the database has to be created first with

    sudo -u postgres createdb pkgdb

or equivalent.    

To get same setup as in production db you should have::

    cat db_setup.cfg
      ...
      # DATABASE
      sqlalchemy.dburi="postgres://postgres@/pkgdb"
      database.common_user='pkgdbadmin'
      database.readonly_user='pkgdbreadonly'
      ...

    sudo -u postgres tg-admin -c db_setup.cfg sql create

If you prefer not to create your database as postgres user you can do something like::

    sudo -u postgres createuser -SDRPE test
      Enter password for new role: <password>
      Enter it again: <password>

    sudo -u postgres createdb -O test test

    cat db_setup.cfg
      ...
      # DATABASE
      sqlalchemy.dburi="postgres://test:test@127.0.0.1/test"
      database.common_user='pkgdbadmin'
      database.readonly_user='pkgdbreadonly'
      ...

    tg-admin -c db_setup.cfg sql create

I prefer to use the later setup for automated testing. 


Start memcached
---------------

Memcached is an optional daemon that can be run to speed up the server.  It
functions by caching certain data that is read many times so that we don't have
to access the database as frequently.  To use it you need to install and start it::

  su -c yum install memcached
  su -c /etc/init.d/memcached start

Setting up the cron jobs
------------------------
If you imported the database dump, skip this section.

A cron job is needed to sync information from the yum repositories into the
packagedb. server-scripts/pkgdb-sync-yum update

For list of params use server-scripts/pkgdb-sync-yum update -h

Other cron jobs are required to sync data out to cvs, bugzilla, and koji
owner-sync-pkgdb
pkgdb-sync-bugzilla

We don't have a good way to test these.latter scripts.

TG FeedController bug
---------------------

We're using an old version of TG (1.0) that no longer gets any updates so
we'll have to modify the local TG everytime.

Apply this patch to turbogears/feeds/feed.py
http://trac.turbogears.org/attachment/ticket/2348/feedkid.diff

And here's the link to the upstream ticket:
http://trac.turbogears.org/ticket/2348

Note: this has been applied to the Fedora and EPEL packages.

App icons as static content
-------------------------------------------
Set server.allow_static_icons to enable static icons. This option influences 
the icon path generation as well as icon import part. This should make setup 
of already running server easier.

Set server.static_media_dir to directory which content is accessible from all 
pkgdb webservers. This path is used by import script as the target location 
of app icon tree. If server.static_media_dir is set to e.g. '/var/pkgdb/static'
'/var/pkgdb/static/appicon/' should be served as /pkgdb/static/appicon by apache.
This can be done by putting following line in webserver configuration:
    Alias /pkgdb/static/appicon /var/pkgdb/static/appicons

App icons tree is updated during regular build db update. Icons are collected in
DB first, when the import is finished the icon tree is updated with the new data.
During import the new icons are served from DB so that we can avoid 404s.

pkgdb-sync-yum has two new commands to admin static app icons:
 - icons2static (-all) will update (regenerate) the app icon tree
 - iconsfromdb will set all icons as unavailable on filesystem so that icons
   will be served from db


Start the Server (The new way)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You'll need to change 'bunbunbun' to your password.

Next copy the httpd-pkgdb.conf file to your apache conf.d directory::

  sudo cp httpd-pkgdb.conf /etc/httpd/conf.d/

Restart apache::

  sudo /etc/init.d/httpd restart

In your favorite web browser, navigate to::
  https://localhost/pkgdb/


Start the Server (The old way)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. warning::

    This method of starting the server is deprecated.  It's helpful for
    quickly bringing up a test instance but using the wsgi server with apache
    is more scalable and how we run things in production.  This is currently
    working (with the 0.4.0 release) but there's not going to be much testing
    to make sure it continues to work.

First copy the pkgdb.cfg.sample file to pkgdb.cfg.  Next, edit pkgdb.cfg to
configure the server to see your database.  You'll need to set fas.username to
a username (your Fedora Account System username will work), fas.password (if
you use your username, your password will work), and sqlalchemy.dburi.  The
dburi line will be something like this::

  sqlalchemy.dburi="postgres://pkgdbadmin:bunbunbun@localhost/pkgdb"

You'll need to change 'bunbunbun' to your password.

Next you'll need a directory for the logs.  You have two options.  The first
is to create a directory in /var/log and change the owner and group to yours
as follows::
  sudo mkdir /var/log/pkgdb
  sudo chown <your username>:<your groupname> /var/log/pkgdb

Or you can edit pkgdb.cfg and change all references to /var/log/pkgdb to a
directory that you own.  For example: if you want to use ~/packagedb/logs,
then change the following lines::
  [[handlers]]
  [[[cron_out]]]
  args="('/var/log/pkgdb/cron.log', 'D', 7)"

  args="('/home/<username>/packagedb/logs/cron.log', 'D', 7)"


  [[[debug_out]]]
  class='TimedRotatingFileHandler'
  args="('/var/log/pkgdb/server.log', 'D', 7)"

  args="('/home/<username>/packagedb/logs/server.log', 'D', 7)"


  [[[access_out]]]
  class='TimedRotatingFileHandler'
  level='INFO'
  args="('/var/log/pkgdb/access.log', 'D', 7)"

  args="('/home/<username>/packagedb/logs/access.log', 'D', 7)"


  [[[error_out]]]
  class='TimedRotatingFileHandler'
  args="('/var/log/pkgdb/server.log', 'D', 7)"

  args="('/home/<username>/packagedb/logs/server.log', 'D', 7)"


Then start the server::

  python start-pkgdb


In your favorite web browser, navigate to::
  http://localhost:8086/pkgdb/


----------------------
Development guidelines
----------------------

Database model
==============
The handling of db model definition described here should allow us to:
 * test pkgdb
 * create full db structure with 'tg-admin sql create'
 * refactor db model more safely
 * better manage db model updates

Whole model definition if kept in pkgdb.model.* modules. Every information needed to create 
db structure same as the production db is included in the model (triggers, stored procedures, 
views, indexes, constraints, permission, necessary initial data...). 

We are using sqlalchemy-migrate to manage database model updates.

In this section you can find a few simple recipies for situations that need extra attention
during the development of database related features.

For more detailed sa-migrate tutorial check the official `sa-migrate docs`_

.. _`sa-migrate docs`: http://packages.python.org/sqlalchemy-migrate/versioning.html#version-control-a-database


New model update
~~~~~~~~~~~~~~~~
Check db version
  % ./manage_db version
  10
  % ./manage_db db_version
  10

Create new update script for your feature/fix
  % ./manage_db script "Add wiki to application"

Edit your update.
Note: To make scripts compatible with sqlalchemy-migrate versions before and after 0.6 we have to modify the tamplate script a bit

  % vim db_repo/versions/011_Add_wiki_to_application.py

    from sqlalchemy import *
    from migrate import *
    import migrate.changeset

    # is sqlalchemy-migrate > 0.5
    if hasattr(migrate.changeset.constraint, 'UniqueConstraint'):
        migrate_engine=None

    metadata = MetaData(migrate_engine)

    app = Table('application', metadata,
                Column('id', Integer, primary_key=True),
                Column('wiki', Text()),
                )

    def upgrade(migrate_engine=migrate_engine):
        metadata.bind = migrate_engine
        app.c.wiki.create()

    def downgrade(migrate_engine=migrate_engine):
        metadata.bind = migrate_engine
        app.c.wiki.drop()


Update the related stuff in pkgdb.model
  % vim pkgdb/model/apps.py

Test your update
  % ./manage_db test
  Upgrading... done
  Downgrading... done
  Success

Check db version
  % ./manage_db version
  11
  % ./manage_db db_version
  10

Upgrade DB
  % ./manage_db upgrade
  10 -> 11... 
  done


Merging updates
~~~~~~~~~~~~~~~
Consider reverting your changes in your local database before merging, it can make 
testing of following merge easier. 

  % ./manage_db downgrade 10
  11 -> 10... 
  done

  % ./manage_db version
  11
  % ./manage_db db_version
  10

Merge your branch and check if there are conflicting 
db updates - look for same update version numbers in db_repo/version/. 

  % ls db_repo/versions/
  ...
  011_Add_wiki_to_application.py
  011_Some_other_cool_feature.py

Don't merge conflicting updates into one file! We want to keep the update scripts as simple as possible.
Append YOUR conflicting updates with higher version number and revise them - updates 
that are now applying before those of yours may have done unexpected changes.

  % mv db_repo/versions/011_Add_wiki_to_application.py db_repo/versions/012_Add_wiki_to_application.py

Test
  % ./manage_db test
  Upgrading... done
  Downgrading... done
  Success

  % ./manage_db version
  12
  % ./manage_db db_version
  10

Upgrade DB
  % ./manage_db upgrade
  10 -> 11... 
  done
  11 -> 12... 
  done


DB merge is done
  

Testing
=======
this section is collection of ideas that needs yet some more work and experience
to get into right shape.

WARNING: don't run the tests on DB you use for development. Create empty DB and set it up in test.cfg.
For more info how to do that consult DB setup section.
Theoretically the tests should be able to run just on sqlite and postgres related stuff be skipped. 
This is no longer supported as incomplete tests makes little sense.

 * before adding new feature, fixing bug, refactoring write test
 * see Makefile for nose usage
 * nose and TestCase is used

Acceptance tests
~~~~~~~~~~~~~~~~
These tests test PkgDB as a blackbox and should be *always* independent on the internals. 
The only exception may be initial DB setup that is difficult to get using webapp.
For more details see http://www.extremeprogramming.org/rules/functionaltests.html

 * run these tests before every commit. 
 * every provided feature should have test. The user story describing the feature should be in comment
 * User story template: As a [user role] I want to [goal] so I can [reason].
 * the tests are locatad in tests/functional
 * % make testfunc
 * check pkgdb.lib.test.WebAppTest and existing tests to start
 * ignored TypeError may arise after tests. Probably bug in python-bugzilla. Reported as bz#625019 (patch included)


Unit tests
~~~~~~~~~~
Unit tests should provide documentation, use cases and guarantee that public API of class or module will not be accidentally
changed or start to behave differently. It is not effective to provide tests for private internal functions
as it make later refactoring difficult.

Writing test first (Test Driven Development) lead by experience to better structured, loosly coupled code 
that is easier to maintain.

 * the tests are located in tests/unit
 * % make test
 * check helpers for DB related stuff in pkgdb.lib.test (its tests are in tests/lib/test_test.py)
 * test as much as possible on in memory sqlite
 * for performance reasons testsuite creates one fresh instance of DB in postgres which can be used by tests. Every single test is responsible for cleaning after itself
 * some tools to make testing easier are in pkgdb.lib.test
 * framework configuration is looked up in test.cfg

------------
Translations
------------

You will need babel and setuptools to translate the messages in the packagedb::
  yum install babel setuptools

Updating the POT File
=====================

When you make changes that change the translatable strings in the package, you
should update the POT file.  Use the following paver command to do that::
  paver extract_messages -o po/fedora-packagedb.pot

Then commit your changes to source control.

Updating the PO Files
=====================

You should merge the new translatable strings into the PO files at the same
time.  Until we build a single paver command for this, we want to do this::
  for po_file in po/*.po ; do
    paver update_catalog -D fedora_packagedb -i po/fedora-packagedb.pot -l `basename $po_file` -d po -o $po_file
  done

Creating a new PO File
======================

If you are working on a translation for the first time, you'll need to create
the PO file.  Run this paver command substituting $LOCALE with the locale you
wish to translate for::
  paver init_catalog -D fedora_packagedb -i po/fedora-packagedb.pot -l $LOCALE -d po -o po/$LOCALE.po

That will initialize a new PO file from the current POT file.  The PO will be
located in po/$LOCALE.po

After creation, this should be committed to the revision control system.

Compiling Message Catalogs
==========================

Message catalogs can be compiled for testing and should always be compiled
just prior to release.  Do this with the following paver command::
  paver make_catalogs

Compiled message catalogs should not be committed to source control.

Installing Message Catalogs
===========================

``paver install_catalogs`` will install the catalogs.  This commmand has been
added to ``paver install``.

-------
Release
-------

We want to get to the place where a release can be made via a paver target.
Currently, this is more involved.

1) Merge everything into the fedora-packagedb-stable branch.  Push the changes to
   the server.  Eventually this should be the last manual step.  Everything
   else should be automated::

     bzr merge [from feature branches]
     bzr commit
     bzr push bzr+ssh://bzr.fedorahosted.org/bzr/packagedb/fedora-packagedb-stable

2) Go to a temporary directory and checkout a copy of stable::
     bzr checkout --lightweight bzr+ssh://bzr.fedorahosted.org/bzr/packagedb/fedora-packagedb-stable/ release

3) Go to that directory and run::
     paver sdist --format bztar

4) copy the dist/fedora-packagedb-VERSION.tar.bz2 and fedora-packagedb.spec files
   to where you build Fedora RPMS.  Do a test build::
     cp dist/fedora-packagedb-*.tar.bz2 fedora-packagedb.spec /srv/cvs/fedora-packagedb/
     pushd /srv/cvs/fedora-packagedb/
     rpmbuild-md5 -bs --nodeps fedora-packagedb.spec
     mock -r epel-5-i386 *.src.rpm

   (rpmbuild-md5 is in the fedora-packager package.)

5) Make sure the build completes.  Run rpmlint on the results.  Install and
   test the new packages::
     rpmlint *rpm
     sudo rpm -Uvh *noarch.rpm
     [test]

6) When satisfied that the build works, tag the repository::
     popd
     bzr tag VERSION
     bzr push bzr+ssh://bzr.fedorahosted.org/bzr/packagedb/fedora-packagedb-stable

7) Upload the tarball to fedorahosted.  Note: The directory is slightly
   different if you're not a fedorahosted admin::
     scp dist/fedora-packagedb*tar.gz fedorahosted.org:/srv/web/releases/p/a/packagedb/

8) Finish building and pushing packages for Fedora.
